# 00002 波动率做市策略测试使用指南

## 快速开始

### 1. 安装依赖

```bash
pip3 install pytest pytest-mock pandas numpy
```

### 2. 运行测试

```bash
cd PolyOMB_Skills/00002_volatility_market_maker/tests
python3 -m pytest
```

## 测试结构

```
tests/
├── conftest.py              # Pytest 共享 Fixtures
├── mock_data_generator.py   # Mock 数据生成器
├── volatility_calc.py       # 波动率计算模块
├── risk_management.py       # 风险管理模块
├── order_pricing.py         # 订单定价模块
├── data_adapter.py          # 数据适配模块
├── backtest_engine.py       # 回测引擎模块
├── test_volatility_calc.py  # 波动率计算测试
├── test_risk_management.py  # 风险管理测试
├── test_order_pricing.py    # 订单定价测试
├── test_data_adapter.py     # 数据适配测试
├── test_backtest_flow.py    # 回测流程测试
├── A0001 测试覆盖率报告.md  # 覆盖率报告
└── A0002 测试使用指南.md    # 本文件
```

## 运行测试

### 基础用法

```bash
# 运行所有测试
python3 -m pytest

# 运行特定测试文件
python3 -m pytest test_volatility_calc.py

# 运行特定测试类
python3 -m pytest test_risk_management.py::TestStopLossLogic

# 运行特定测试方法
python3 -m pytest test_risk_management.py::TestStopLossLogic::test_stop_loss_triggered_by_pnl
```

### 详细输出

```bash
# 显示详细输出
python3 -m pytest -v

# 显示更详细的错误信息
python3 -m pytest -vv

# 显示测试进度
python3 -m pytest --tb=short
```

### 标记筛选

```bash
# 运行 SMB 测试（需要真实 SMB 环境）
python3 -m pytest --run-smb

# 跳过慢速测试
python3 -m pytest -m "not slow"

# 只运行 SMB 测试
python3 -m pytest -m smb

# 只运行慢速测试
python3 -m pytest -m slow
```

## 测试 Fixtures

### 可用 Fixtures

| Fixture | 说明 | 用途 |
|---------|------|------|
| `sample_trades_1k` | 1000条模拟交易数据 | 波动率计算、回测测试 |
| `sample_market_metadata` | 市场元数据 | 数据适配测试 |
| `sample_orderbook_snapshots` | 订单簿快照 | 订单定价测试 |
| `sample_position_history` | 持仓历史 | 回测结果验证 |
| `mock_smb_adapter` | Mock SMB 适配器 | 数据适配测试 |
| `default_skill_config` | 默认配置 | 策略初始化 |
| `mock_environment_vars` | 环境变量 | 配置测试 |

### 使用 Fixtures

```python
def test_example(sample_trades_1k):
    """使用 sample_trades_1k fixture 的示例"""
    assert len(sample_trades_1k) == 1000
    assert 'price' in sample_trades_1k.columns
```

## 生成 Mock 数据

### 使用 Mock 数据生成器

```bash
# 生成所有 Mock 数据
python3 mock_data_generator.py

# 指定市场 ID
python3 mock_data_generator.py --market-id 0x2189...

# 指定输出目录
python3 mock_data_generator.py --output ./my_mock_data

# 指定交易数量
python3 mock_data_generator.py --n-trades 5000
```

## 模块使用示例

### 波动率计算

```python
from volatility_calc import calculate_volatility, calculate_rolling_volatility

# 基础波动率计算
prices = pd.Series([0.50, 0.52, 0.48, 0.51, 0.53])
vol = calculate_volatility(prices)
print(f"波动率: {vol:.4f}")

# 滚动波动率
df = pd.DataFrame({
    'timestamp': pd.date_range('2024-01-01', periods=100, freq='1min'),
    'price': np.random.normal(0.5, 0.02, 100)
})
rolling_vol = calculate_rolling_volatility(df, window='3h')
```

### 风险管理

```python
from risk_management import RiskManager, should_trigger_stop_loss

# 使用风险管理器
config = {
    'stop_loss_threshold': -5.0,
    'take_profit_threshold': 3.0,
    'volatility_threshold': 0.15,
    'max_position_size': 250,
}
manager = RiskManager(config)

# 检查风险
result = manager.check_risk(
    pnl=-2.0,
    spread=0.01,
    volatility_3h=0.10,
    position_size=150
)
print(f"是否可以交易: {result.can_trade}")
print(f"风险等级: {result.risk_level}")

# 直接检查止损
should_stop = should_trigger_stop_loss(
    pnl=-6.0,
    spread=0.01,
    stop_loss_threshold=-5.0,
    spread_threshold=0.02
)
```

### 订单定价

```python
from order_pricing import get_order_prices, OrderPricer

# 直接计算价格
order_book = {
    'best_bid': 0.65,
    'best_ask': 0.67,
    'best_bid_size': 100,
    'best_ask_size': 100,
}
bid, ask = get_order_prices(order_book, avg_price=0.66)
print(f"买价: {bid}, 卖价: {ask}")

# 使用定价器类
pricer = OrderPricer(tick_size=0.01, min_spread=0.01, max_spread=0.05)
bid, ask = pricer.get_prices(order_book, position_size=100)
```

### 数据适配

```python
from data_adapter import SMBDataAdapter, extract_price_series

# SMB 适配器
adapter = SMBDataAdapter("smb://server/share/data")
adapter.mount()
trades = adapter.get_market_trades("market_id")
adapter.unmount()

# 提取价格序列
prices = extract_price_series(trades, interval='1min')
```

### 回测引擎

```python
from backtest_engine import run_backtest, VolatilityMarketMakerStrategy

# 便捷函数
result = run_backtest(data, config, initial_capital=10000)
print(f"总盈亏: {result.total_pnl}")
print(f"交易次数: {result.trade_count}")
print(f"夏普比率: {result.statistics['sharpe_ratio']}")

# 手动运行
strategy = VolatilityMarketMakerStrategy(config)
engine = BacktestEngine(strategy, initial_capital=10000)
result = engine.run(data)
```

## 编写新测试

### 基本测试结构

```python
import pytest
from volatility_calc import calculate_volatility

class TestNewFeature:
    """新功能测试类"""
    
    def test_basic_case(self):
        """测试基础场景"""
        result = calculate_volatility(pd.Series([0.5, 0.51, 0.52]))
        assert result > 0
    
    def test_edge_case(self):
        """测试边界情况"""
        with pytest.raises(ValueError):
            calculate_volatility(pd.Series([]))
    
    def test_with_fixture(self, sample_trades_1k):
        """使用 fixture 的测试"""
        assert len(sample_trades_1k) == 1000
```

### 使用标记

```python
import pytest

@pytest.mark.slow
def test_performance():
    """慢速测试"""
    pass

@pytest.mark.smb
def test_smb_connection():
    """需要 SMB 的测试"""
    pass
```

## 常见问题

### Q: 测试失败时如何调试？

```bash
# 使用 -x 在第一个失败时停止
python3 -m pytest -x

# 使用 --pdb 进入调试模式
python3 -m pytest --pdb

# 显示完整的错误信息
python3 -m pytest --tb=long
```

### Q: 如何跳过某些测试？

```bash
# 跳过 SMB 测试
python3 -m pytest -m "not smb"

# 跳过慢速测试
python3 -m pytest -m "not slow"

# 同时跳过多个标记
python3 -m pytest -m "not smb and not slow"
```

### Q: 如何并行运行测试？

```bash
# 安装 pytest-xdist
pip3 install pytest-xdist

# 并行运行（4个进程）
python3 -m pytest -n 4
```

## 最佳实践

1. **每个测试只测试一个概念**
2. **使用描述性的测试名称**
3. **使用 fixtures 共享测试数据**
4. **测试边界情况和异常情况**
5. **保持测试独立性**
6. **使用适当的标记分类测试**

## 相关文档

- [测试覆盖率报告](A0001%20测试覆盖率报告.md)
- [Mock 数据生成器说明](mock_data_generator.py)
- [项目 README](../README.md)
